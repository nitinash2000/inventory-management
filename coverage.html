
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>handlers: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">inventory-management/handlers/articleHandler.go (100.0%)</option>
				
				<option value="file1">inventory-management/handlers/orderHandler.go (0.0%)</option>
				
				<option value="file2">inventory-management/handlers/userHandler.go (0.0%)</option>
				
				<option value="file3">inventory-management/main.go (0.0%)</option>
				
				<option value="file4">inventory-management/models/orders.go (0.0%)</option>
				
				<option value="file5">inventory-management/models/user.go (0.0%)</option>
				
				<option value="file6">inventory-management/repository/addressRepo.go (100.0%)</option>
				
				<option value="file7">inventory-management/repository/articleRepo.go (100.0%)</option>
				
				<option value="file8">inventory-management/repository/mocks/mock_addressRepo.go (0.0%)</option>
				
				<option value="file9">inventory-management/repository/mocks/mock_articleRepo.go (0.0%)</option>
				
				<option value="file10">inventory-management/repository/mocks/mock_orderItemRepo.go (0.0%)</option>
				
				<option value="file11">inventory-management/repository/mocks/mock_orderRepo.go (0.0%)</option>
				
				<option value="file12">inventory-management/repository/mocks/mock_userRepo.go (0.0%)</option>
				
				<option value="file13">inventory-management/repository/orderItemRepo.go (75.0%)</option>
				
				<option value="file14">inventory-management/repository/orderRepo.go (100.0%)</option>
				
				<option value="file15">inventory-management/repository/userRepo.go (100.0%)</option>
				
				<option value="file16">inventory-management/routes/articleRoutes.go (0.0%)</option>
				
				<option value="file17">inventory-management/routes/orderRoutes.go (0.0%)</option>
				
				<option value="file18">inventory-management/routes/router.go (0.0%)</option>
				
				<option value="file19">inventory-management/routes/userRoutes.go (0.0%)</option>
				
				<option value="file20">inventory-management/services/articles/articleService.go (100.0%)</option>
				
				<option value="file21">inventory-management/services/mocks/mock_articleService.go (0.0%)</option>
				
				<option value="file22">inventory-management/services/mocks/mock_orderService.go (0.0%)</option>
				
				<option value="file23">inventory-management/services/mocks/mock_userService.go (0.0%)</option>
				
				<option value="file24">inventory-management/services/orders/orderService.go (81.0%)</option>
				
				<option value="file25">inventory-management/services/users/userService.go (87.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package handlers

import (
        "inventory-management/dtos"
        "inventory-management/services/articles"
        "net/http"

        "github.com/gin-gonic/gin"
)

type articleHandler struct {
        articleService articles.ArticleService
}

func NewArticleHandler(articleService articles.ArticleService) *articleHandler <span class="cov8" title="1">{
        return &amp;articleHandler{
                articleService: articleService,
        }
}</span>

func (a *articleHandler) GetArticle(ctx *gin.Context) <span class="cov8" title="1">{
        id := ctx.Param("id")

        article, err := a.articleService.GetArticle(id)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, article)</span>
}

func (a *articleHandler) CreateArticle(ctx *gin.Context) <span class="cov8" title="1">{
        var req *dtos.Article

        err := ctx.ShouldBindJSON(&amp;req)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov8" title="1">err = a.articleService.CreateArticle(req)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, gin.H{"message": "Article created successfully"})</span>
}

func (a *articleHandler) DeleteArticle(ctx *gin.Context) <span class="cov8" title="1">{
        id := ctx.Param("id")

        err := a.articleService.DeleteArticle(id)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, gin.H{"message": "Article deleted successfully"})</span>
}

func (a *articleHandler) UpdateArticle(ctx *gin.Context) <span class="cov8" title="1">{
        id := ctx.Param("id")

        var req dtos.Article
        err := ctx.ShouldBindJSON(&amp;req)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov8" title="1">err = a.articleService.UpdateArticle(id, &amp;req)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, gin.H{"message": "Updated article successfully"})</span>
}

func (a *articleHandler) ListArticles(ctx *gin.Context) <span class="cov8" title="1">{
        articles, err := a.articleService.ListArticle()
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, articles)</span>
}

func (a *articleHandler) UpdateArticleStock(ctx *gin.Context) <span class="cov8" title="1">{
        id := ctx.Param("id")
        var req *dtos.UpdateStock

        err := ctx.ShouldBindJSON(&amp;req)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov8" title="1">err = a.articleService.UpdateArticleStock(id, req)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(http.StatusOK, gin.H{"message": "Article stock updated successfully"})</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package handlers

import (
        "inventory-management/dtos"
        "inventory-management/services/orders"
        "net/http"

        "github.com/gin-gonic/gin"
)

type orderHandler struct {
        orderService orders.OrderService
}

func NewOrderHandler(orderService orders.OrderService) *orderHandler <span class="cov0" title="0">{
        return &amp;orderHandler{
                orderService: orderService,
        }
}</span>

func (o *orderHandler) GetOrder(ctx *gin.Context) <span class="cov0" title="0">{
        id := ctx.Param("id")

        order, err := o.orderService.GetOrder(id)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, order)</span>
}

func (o *orderHandler) CreateOrder(ctx *gin.Context) <span class="cov0" title="0">{
        var req *dtos.Order

        err := ctx.ShouldBindJSON(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">err = o.orderService.CreateOrder(req)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": "Order created successfully"})</span>
}

func (o *orderHandler) DeleteOrder(ctx *gin.Context) <span class="cov0" title="0">{
        id := ctx.Param("id")

        err := o.orderService.DeleteOrder(id)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": "Order deleted successfully"})</span>
}

func (o *orderHandler) UpdateOrder(ctx *gin.Context) <span class="cov0" title="0">{
        id := ctx.Param("id")

        var req dtos.Order
        err := ctx.ShouldBindJSON(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">err = o.orderService.UpdateOrder(id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": "Updated order successfully"})</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handlers

import (
        "inventory-management/dtos"
        "inventory-management/services/users"
        "net/http"

        "github.com/gin-gonic/gin"
)

type userHandler struct {
        userService users.UserService
}

func NewUserHandler(userService users.UserService) *userHandler <span class="cov0" title="0">{
        return &amp;userHandler{
                userService: userService,
        }
}</span>

func (c *userHandler) GetUser(ctx *gin.Context) <span class="cov0" title="0">{
        id := ctx.Param("id")

        user, err := c.userService.GetUser(id)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, user)</span>
}

func (c *userHandler) CreateUser(ctx *gin.Context) <span class="cov0" title="0">{
        var req *dtos.User

        err := ctx.ShouldBindJSON(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">err = c.userService.CreateUser(req)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": "User created successfully"})</span>
}

func (c *userHandler) DeleteUser(ctx *gin.Context) <span class="cov0" title="0">{
        id := ctx.Param("id")

        err := c.userService.DeleteUser(id)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": "User deleted successfully"})</span>
}

func (c *userHandler) UpdateUser(ctx *gin.Context) <span class="cov0" title="0">{
        id := ctx.Param("id")

        var req dtos.User
        err := ctx.ShouldBindJSON(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, err.Error())
                return
        }</span>

        <span class="cov0" title="0">err = c.userService.UpdateUser(id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": "Updated user successfully"})</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "encoding/json"
        "fmt"
        "inventory-management/config"
        "inventory-management/routes"
        "log"
        "os"

        "github.com/gin-gonic/gin"
        "gorm.io/driver/mysql"
        "gorm.io/gorm"
)

func GetConfig(filePath string) (*config.Config, error) <span class="cov0" title="0">{
        file, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var config config.Config
        err = json.Unmarshal(file, &amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

func main() <span class="cov0" title="0">{
        env := os.Getenv("env")
        if env == "" </span><span class="cov0" title="0">{
                env = "default"
        }</span>

        <span class="cov0" title="0">config, err := GetConfig(fmt.Sprintf("%s.json", env))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error loading config: %v", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">db, err := gorm.Open(mysql.Open(config.DbUrl), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to connect to the database: %v", err)
                os.Exit(0)
        }</span>

        <span class="cov0" title="0">if config.ServerPort == "" </span><span class="cov0" title="0">{
                config.ServerPort = "8080"
        }</span>

        <span class="cov0" title="0">r := gin.Default()

        routes.Router(r, db)

        r.Run(":" + config.ServerPort)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package models

import (
        "errors"
        "time"

        "gorm.io/gorm"
)

type Order struct {
        OrderId     string    `json:"order_id" gorm:"primaryKey"`
        CustomerId  string    `json:"customer_id"`
        OrderedAt   time.Time `json:"ordered_at"`
        TotalAmount float64   `json:"total_amount"`
        NoOfItems   int       `json:"no_of_items"`
}

func (o *Order) BeforeSave(tx *gorm.DB) error <span class="cov0" title="0">{
        if o.CustomerId == "" </span><span class="cov0" title="0">{
                return errors.New("customer id is required")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type OrderItem struct {
        OrderItemId string `json:"order_item_id" gorm:"primaryKey"`
        OrderId     string `json:"order_id"`
        ArticleId   string `json:"article_id"`
        Quantity    int    `json:"quantity"`
}

func (oi *OrderItem) BeforeSave(tx *gorm.DB) error <span class="cov0" title="0">{
        if oi.ArticleId == "" </span><span class="cov0" title="0">{
                return errors.New("article id is required")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package models

import (
        "errors"
        "strings"

        "gorm.io/gorm"
)

type User struct {
        Id        string `json:"id" gorm:"primaryKey"`
        Name      string `json:"name"`
        Email     string `json:"email"`
        Mobile    string `json:"mobile"`
        AddressId string `json:"address_id"`
        Role      string `json:"role"`
}

func (u *User) BeforeSave(tx *gorm.DB) error <span class="cov0" title="0">{
        if strings.TrimSpace(u.Name) == "" </span><span class="cov0" title="0">{
                return errors.New("name is required")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Address struct {
        AddressId string `json:"address_id" gorm:"primaryKey"`
        Line1     string `json:"line1"`
        Line2     string `json:"line2"`
        City      string `json:"city"`
        State     string `json:"state"`
        Country   string `json:"country"`
        ZipCode   string `json:"zip_code"`
}

func (a *Address) BeforeSave(tx *gorm.DB) error <span class="cov0" title="0">{
        if strings.TrimSpace(a.Country) == "" </span><span class="cov0" title="0">{
                return errors.New("country is required")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package repository

import (
        "errors"
        "inventory-management/models"

        "gorm.io/gorm"
)

type AddressRepo interface {
        Upsert(address *models.Address) error
        Update(addressId string, address *models.Address) error
        Get(addressId string) (*models.Address, error)
        Delete(addressId string) error
}

type addressRepo struct {
        db *gorm.DB
}

func NewAddressRepo(db *gorm.DB) AddressRepo <span class="cov8" title="1">{
        return &amp;addressRepo{
                db: db,
        }
}</span>

func (o *addressRepo) getTable() string <span class="cov8" title="1">{
        return "addresses"
}</span>

func (o *addressRepo) Upsert(address *models.Address) error <span class="cov8" title="1">{
        err := o.db.Table(o.getTable()).Save(address).Error
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (o *addressRepo) Update(addressId string, address *models.Address) error <span class="cov8" title="1">{
        tx := o.db.Table(o.getTable()).Where("address_id = ?", addressId).UpdateColumns(address)
        if tx.Error != nil || tx.RowsAffected == 0 </span><span class="cov8" title="1">{
                return errors.New("error updating address")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (o *addressRepo) Get(addressId string) (*models.Address, error) <span class="cov8" title="1">{
        var result *models.Address

        err := o.db.Table(o.getTable()).Where("address_id = ?", addressId).First(&amp;result).Error
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

func (o *addressRepo) Delete(addressId string) error <span class="cov8" title="1">{
        tx := o.db.Table(o.getTable()).Where("address_id = ?", addressId).Delete(&amp;models.Address{})
        if tx.Error != nil || tx.RowsAffected == 0 </span><span class="cov8" title="1">{
                return errors.New("error deleting address")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package repository

import (
        "errors"
        "inventory-management/constants"
        "inventory-management/models"

        "gorm.io/gorm"
)

type ArticleRepo interface {
        Create(article *models.Article) error
        Update(articleId string, article *models.Article) error
        Get(articleId string) (*models.Article, error)
        GetAll() ([]*models.Article, error)
        Delete(articleId string) error
        UpdateArticleStock(articleId string, stock int64) error
}

type articleRepo struct {
        db *gorm.DB
}

func NewArticleRepo(db *gorm.DB) ArticleRepo <span class="cov8" title="1">{
        return &amp;articleRepo{
                db: db,
        }
}</span>

func (a *articleRepo) getTable() string <span class="cov8" title="1">{
        return "articles"
}</span>

func (a *articleRepo) Create(article *models.Article) error <span class="cov8" title="1">{
        err := a.db.Table(a.getTable()).Create(article).Error
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (a *articleRepo) Update(articleId string, article *models.Article) error <span class="cov8" title="1">{
        tx := a.db.Table(a.getTable()).Where("article_id = ?", articleId).UpdateColumns(article)
        if tx.Error != nil || tx.RowsAffected == 0 </span><span class="cov8" title="1">{
                return errors.New("error updating article")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (a *articleRepo) Get(articleId string) (*models.Article, error) <span class="cov8" title="1">{
        var result *models.Article

        err := a.db.Table(a.getTable()).Where("article_id = ?", articleId).First(&amp;result).Error
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

func (a *articleRepo) GetAll() ([]*models.Article, error) <span class="cov8" title="1">{
        var result []*models.Article

        err := a.db.Table(a.getTable()).Where("1=1").Find(&amp;result).Error
        if err != nil || len(result) == 0 </span><span class="cov8" title="1">{
                return nil, constants.ErrorNotFound
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

func (a *articleRepo) Delete(articleId string) error <span class="cov8" title="1">{
        tx := a.db.Table(a.getTable()).Where("article_id = ?", articleId).Delete(&amp;models.Article{})
        if tx.Error != nil || tx.RowsAffected == 0 </span><span class="cov8" title="1">{
                return errors.New("error deleting article")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (a *articleRepo) UpdateArticleStock(articleId string, stock int64) error <span class="cov8" title="1">{
        tx := a.db.Table(a.getTable()).Where("article_id = ?", articleId).Update("stock", stock)
        if tx.Error != nil || tx.RowsAffected == 0 </span><span class="cov8" title="1">{
                return errors.New("error updating stock")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: repository/addressRepo.go

// Package mocks is a generated GoMock package.
package mocks

import (
        models "inventory-management/models"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockAddressRepo is a mock of AddressRepo interface.
type MockAddressRepo struct {
        ctrl     *gomock.Controller
        recorder *MockAddressRepoMockRecorder
}

// MockAddressRepoMockRecorder is the mock recorder for MockAddressRepo.
type MockAddressRepoMockRecorder struct {
        mock *MockAddressRepo
}

// NewMockAddressRepo creates a new mock instance.
func NewMockAddressRepo(ctrl *gomock.Controller) *MockAddressRepo <span class="cov0" title="0">{
        mock := &amp;MockAddressRepo{ctrl: ctrl}
        mock.recorder = &amp;MockAddressRepoMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAddressRepo) EXPECT() *MockAddressRepoMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Delete mocks base method.
func (m *MockAddressRepo) Delete(addressId string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", addressId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockAddressRepoMockRecorder) Delete(addressId interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockAddressRepo)(nil).Delete), addressId)
}</span>

// Get mocks base method.
func (m *MockAddressRepo) Get(addressId string) (*models.Address, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", addressId)
        ret0, _ := ret[0].(*models.Address)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockAddressRepoMockRecorder) Get(addressId interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockAddressRepo)(nil).Get), addressId)
}</span>

// Update mocks base method.
func (m *MockAddressRepo) Update(addressId string, address *models.Address) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", addressId, address)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockAddressRepoMockRecorder) Update(addressId, address interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockAddressRepo)(nil).Update), addressId, address)
}</span>

// Upsert mocks base method.
func (m *MockAddressRepo) Upsert(address *models.Address) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Upsert", address)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Upsert indicates an expected call of Upsert.
func (mr *MockAddressRepoMockRecorder) Upsert(address interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upsert", reflect.TypeOf((*MockAddressRepo)(nil).Upsert), address)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: repository/articleRepo.go

// Package mocks is a generated GoMock package.
package mocks

import (
        models "inventory-management/models"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockArticleRepo is a mock of ArticleRepo interface.
type MockArticleRepo struct {
        ctrl     *gomock.Controller
        recorder *MockArticleRepoMockRecorder
}

// MockArticleRepoMockRecorder is the mock recorder for MockArticleRepo.
type MockArticleRepoMockRecorder struct {
        mock *MockArticleRepo
}

// NewMockArticleRepo creates a new mock instance.
func NewMockArticleRepo(ctrl *gomock.Controller) *MockArticleRepo <span class="cov0" title="0">{
        mock := &amp;MockArticleRepo{ctrl: ctrl}
        mock.recorder = &amp;MockArticleRepoMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockArticleRepo) EXPECT() *MockArticleRepoMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockArticleRepo) Create(article *models.Article) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", article)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockArticleRepoMockRecorder) Create(article interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockArticleRepo)(nil).Create), article)
}</span>

// Delete mocks base method.
func (m *MockArticleRepo) Delete(articleId string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", articleId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockArticleRepoMockRecorder) Delete(articleId interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockArticleRepo)(nil).Delete), articleId)
}</span>

// Get mocks base method.
func (m *MockArticleRepo) Get(articleId string) (*models.Article, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", articleId)
        ret0, _ := ret[0].(*models.Article)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockArticleRepoMockRecorder) Get(articleId interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockArticleRepo)(nil).Get), articleId)
}</span>

// GetAll mocks base method.
func (m *MockArticleRepo) GetAll() ([]*models.Article, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAll")
        ret0, _ := ret[0].([]*models.Article)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetAll indicates an expected call of GetAll.
func (mr *MockArticleRepoMockRecorder) GetAll() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAll", reflect.TypeOf((*MockArticleRepo)(nil).GetAll))
}</span>

// Update mocks base method.
func (m *MockArticleRepo) Update(articleId string, article *models.Article) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", articleId, article)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockArticleRepoMockRecorder) Update(articleId, article interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockArticleRepo)(nil).Update), articleId, article)
}</span>

// UpdateArticleStock mocks base method.
func (m *MockArticleRepo) UpdateArticleStock(articleId string, stock int64) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateArticleStock", articleId, stock)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateArticleStock indicates an expected call of UpdateArticleStock.
func (mr *MockArticleRepoMockRecorder) UpdateArticleStock(articleId, stock interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateArticleStock", reflect.TypeOf((*MockArticleRepo)(nil).UpdateArticleStock), articleId, stock)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: repository/orderItemRepo.go

// Package mocks is a generated GoMock package.
package mocks

import (
        models "inventory-management/models"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockOrderItemRepo is a mock of OrderItemRepo interface.
type MockOrderItemRepo struct {
        ctrl     *gomock.Controller
        recorder *MockOrderItemRepoMockRecorder
}

// MockOrderItemRepoMockRecorder is the mock recorder for MockOrderItemRepo.
type MockOrderItemRepoMockRecorder struct {
        mock *MockOrderItemRepo
}

// NewMockOrderItemRepo creates a new mock instance.
func NewMockOrderItemRepo(ctrl *gomock.Controller) *MockOrderItemRepo <span class="cov0" title="0">{
        mock := &amp;MockOrderItemRepo{ctrl: ctrl}
        mock.recorder = &amp;MockOrderItemRepoMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockOrderItemRepo) EXPECT() *MockOrderItemRepoMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockOrderItemRepo) Create(orderItem ...*models.OrderItem) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{}
        for _, a := range orderItem </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "Create", varargs...)
        ret0, _ := ret[0].(error)
        return ret0</span>
}

// Create indicates an expected call of Create.
func (mr *MockOrderItemRepoMockRecorder) Create(orderItem ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockOrderItemRepo)(nil).Create), orderItem...)
}</span>

// Delete mocks base method.
func (m *MockOrderItemRepo) Delete(orderItemId string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", orderItemId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockOrderItemRepoMockRecorder) Delete(orderItemId interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockOrderItemRepo)(nil).Delete), orderItemId)
}</span>

// DeleteAll mocks base method.
func (m *MockOrderItemRepo) DeleteAll(orderItemIds []string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteAll", orderItemIds)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteAll indicates an expected call of DeleteAll.
func (mr *MockOrderItemRepoMockRecorder) DeleteAll(orderItemIds interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteAll", reflect.TypeOf((*MockOrderItemRepo)(nil).DeleteAll), orderItemIds)
}</span>

// Get mocks base method.
func (m *MockOrderItemRepo) Get(orderItemId string) (*models.OrderItem, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", orderItemId)
        ret0, _ := ret[0].(*models.OrderItem)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockOrderItemRepoMockRecorder) Get(orderItemId interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockOrderItemRepo)(nil).Get), orderItemId)
}</span>

// GetByOrder mocks base method.
func (m *MockOrderItemRepo) GetByOrder(orderId string) ([]*models.OrderItem, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByOrder", orderId)
        ret0, _ := ret[0].([]*models.OrderItem)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByOrder indicates an expected call of GetByOrder.
func (mr *MockOrderItemRepoMockRecorder) GetByOrder(orderId interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByOrder", reflect.TypeOf((*MockOrderItemRepo)(nil).GetByOrder), orderId)
}</span>

// Update mocks base method.
func (m *MockOrderItemRepo) Update(orderItemId string, orderItem *models.OrderItem) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", orderItemId, orderItem)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockOrderItemRepoMockRecorder) Update(orderItemId, orderItem interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockOrderItemRepo)(nil).Update), orderItemId, orderItem)
}</span>

// Upsert mocks base method.
func (m *MockOrderItemRepo) Upsert(orderItems ...*models.OrderItem) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{}
        for _, a := range orderItems </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "Upsert", varargs...)
        ret0, _ := ret[0].(error)
        return ret0</span>
}

// Upsert indicates an expected call of Upsert.
func (mr *MockOrderItemRepoMockRecorder) Upsert(orderItems ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upsert", reflect.TypeOf((*MockOrderItemRepo)(nil).Upsert), orderItems...)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: repository/orderRepo.go

// Package mocks is a generated GoMock package.
package mocks

import (
        models "inventory-management/models"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockOrderRepo is a mock of OrderRepo interface.
type MockOrderRepo struct {
        ctrl     *gomock.Controller
        recorder *MockOrderRepoMockRecorder
}

// MockOrderRepoMockRecorder is the mock recorder for MockOrderRepo.
type MockOrderRepoMockRecorder struct {
        mock *MockOrderRepo
}

// NewMockOrderRepo creates a new mock instance.
func NewMockOrderRepo(ctrl *gomock.Controller) *MockOrderRepo <span class="cov0" title="0">{
        mock := &amp;MockOrderRepo{ctrl: ctrl}
        mock.recorder = &amp;MockOrderRepoMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockOrderRepo) EXPECT() *MockOrderRepoMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockOrderRepo) Create(order *models.Order) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", order)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockOrderRepoMockRecorder) Create(order interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockOrderRepo)(nil).Create), order)
}</span>

// Delete mocks base method.
func (m *MockOrderRepo) Delete(orderId string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", orderId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockOrderRepoMockRecorder) Delete(orderId interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockOrderRepo)(nil).Delete), orderId)
}</span>

// Get mocks base method.
func (m *MockOrderRepo) Get(orderId string) (*models.Order, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", orderId)
        ret0, _ := ret[0].(*models.Order)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockOrderRepoMockRecorder) Get(orderId interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockOrderRepo)(nil).Get), orderId)
}</span>

// Update mocks base method.
func (m *MockOrderRepo) Update(orderId string, order *models.Order) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", orderId, order)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockOrderRepoMockRecorder) Update(orderId, order interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockOrderRepo)(nil).Update), orderId, order)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: repository/userRepo.go

// Package mocks is a generated GoMock package.
package mocks

import (
        models "inventory-management/models"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockUserRepo is a mock of UserRepo interface.
type MockUserRepo struct {
        ctrl     *gomock.Controller
        recorder *MockUserRepoMockRecorder
}

// MockUserRepoMockRecorder is the mock recorder for MockUserRepo.
type MockUserRepoMockRecorder struct {
        mock *MockUserRepo
}

// NewMockUserRepo creates a new mock instance.
func NewMockUserRepo(ctrl *gomock.Controller) *MockUserRepo <span class="cov0" title="0">{
        mock := &amp;MockUserRepo{ctrl: ctrl}
        mock.recorder = &amp;MockUserRepoMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserRepo) EXPECT() *MockUserRepoMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Delete mocks base method.
func (m *MockUserRepo) Delete(userId string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", userId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockUserRepoMockRecorder) Delete(userId interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockUserRepo)(nil).Delete), userId)
}</span>

// Get mocks base method.
func (m *MockUserRepo) Get(userId string) (*models.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", userId)
        ret0, _ := ret[0].(*models.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockUserRepoMockRecorder) Get(userId interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockUserRepo)(nil).Get), userId)
}</span>

// Update mocks base method.
func (m *MockUserRepo) Update(userId string, user *models.User) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", userId, user)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockUserRepoMockRecorder) Update(userId, user interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockUserRepo)(nil).Update), userId, user)
}</span>

// Upsert mocks base method.
func (m *MockUserRepo) Upsert(user *models.User) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Upsert", user)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Upsert indicates an expected call of Upsert.
func (mr *MockUserRepoMockRecorder) Upsert(user interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upsert", reflect.TypeOf((*MockUserRepo)(nil).Upsert), user)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package repository

import (
        "errors"
        "inventory-management/models"

        "gorm.io/gorm"
)

type OrderItemRepo interface {
        Create(orderItem ...*models.OrderItem) error
        Update(orderItemId string, orderItem *models.OrderItem) error
        Get(orderItemId string) (*models.OrderItem, error)
        Delete(orderItemId string) error
        GetByOrder(orderId string) ([]*models.OrderItem, error)
        Upsert(orderItems ...*models.OrderItem) error
        DeleteAll(orderItemIds []string) error
}

type orderItemRepo struct {
        db *gorm.DB
}

func NewOrderItemRepo(db *gorm.DB) OrderItemRepo <span class="cov8" title="1">{
        return &amp;orderItemRepo{
                db: db,
        }
}</span>

func (o *orderItemRepo) getTable() string <span class="cov8" title="1">{
        return "order_items"
}</span>

func (o *orderItemRepo) Create(orderItem ...*models.OrderItem) error <span class="cov8" title="1">{
        err := o.db.Table(o.getTable()).Save(orderItem).Error
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (o *orderItemRepo) Update(orderItemId string, orderItem *models.OrderItem) error <span class="cov8" title="1">{
        tx := o.db.Table(o.getTable()).Where("order_item_id = ?", orderItemId).UpdateColumns(orderItem)
        if tx.Error != nil || tx.RowsAffected == 0 </span><span class="cov8" title="1">{
                return errors.New("error updating orderItem")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (o *orderItemRepo) Upsert(orderItems ...*models.OrderItem) error <span class="cov0" title="0">{
        err := o.db.Table(o.getTable()).Save(&amp;orderItems).Error
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (o *orderItemRepo) Get(orderItemId string) (*models.OrderItem, error) <span class="cov8" title="1">{
        var result *models.OrderItem

        err := o.db.Table(o.getTable()).Where("order_item_id = ?", orderItemId).First(&amp;result).Error
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

func (o *orderItemRepo) Delete(orderItemId string) error <span class="cov8" title="1">{
        tx := o.db.Table(o.getTable()).Where("order_item_id = ?", orderItemId).Delete(&amp;models.OrderItem{})
        if tx.Error != nil || tx.RowsAffected == 0 </span><span class="cov8" title="1">{
                return errors.New("error deleting orderItem")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (o *orderItemRepo) GetByOrder(orderId string) ([]*models.OrderItem, error) <span class="cov8" title="1">{
        var result []*models.OrderItem

        err := o.db.Table(o.getTable()).Where("order_id = ?", orderId).Find(&amp;result).Error
        if err != nil || len(result) == 0 </span><span class="cov8" title="1">{
                return nil, errors.New("error getting orderItems")
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

func (o *orderItemRepo) DeleteAll(orderItemIds []string) error <span class="cov0" title="0">{
        tx := o.db.Table(o.getTable()).Where(`order_item_id IN (?)1`, orderItemIds).Delete(&amp;models.OrderItem{})
        if tx.Error != nil || tx.RowsAffected == 0 </span><span class="cov0" title="0">{
                return errors.New("error deleting orderItem")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package repository

import (
        "errors"
        "inventory-management/models"

        "gorm.io/gorm"
)

type OrderRepo interface {
        Create(order *models.Order) error
        Update(orderId string, order *models.Order) error
        Get(orderId string) (*models.Order, error)
        Delete(orderId string) error
}

type orderRepo struct {
        db *gorm.DB
}

func NewOrderRepo(db *gorm.DB) OrderRepo <span class="cov8" title="1">{
        return &amp;orderRepo{
                db: db,
        }
}</span>

func (o *orderRepo) getTable() string <span class="cov8" title="1">{
        return "orders"
}</span>

func (o *orderRepo) Create(order *models.Order) error <span class="cov8" title="1">{
        err := o.db.Table(o.getTable()).Save(order).Error
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (o *orderRepo) Update(orderId string, order *models.Order) error <span class="cov8" title="1">{
        tx := o.db.Table(o.getTable()).Where("order_id = ?", orderId).UpdateColumns(order)
        if tx.Error != nil || tx.RowsAffected == 0 </span><span class="cov8" title="1">{
                return errors.New("error updating order")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (o *orderRepo) Get(orderId string) (*models.Order, error) <span class="cov8" title="1">{
        var result *models.Order

        err := o.db.Table(o.getTable()).Where("order_id = ?", orderId).First(&amp;result).Error
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

func (o *orderRepo) Delete(orderId string) error <span class="cov8" title="1">{
        tx := o.db.Table(o.getTable()).Where("order_id = ?", orderId).Delete(&amp;models.Order{})
        if tx.Error != nil || tx.RowsAffected == 0 </span><span class="cov8" title="1">{
                return errors.New("error deleting order")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package repository

import (
        "errors"
        "inventory-management/models"

        "gorm.io/gorm"
)

type UserRepo interface {
        Upsert(user *models.User) error
        Update(userId string, user *models.User) error
        Get(userId string) (*models.User, error)
        Delete(userId string) error
}

type userRepo struct {
        db *gorm.DB
}

func NewUserRepo(db *gorm.DB) UserRepo <span class="cov8" title="1">{
        return &amp;userRepo{
                db: db,
        }
}</span>

func (o *userRepo) getTable() string <span class="cov8" title="1">{
        return "users"
}</span>

func (o *userRepo) Upsert(user *models.User) error <span class="cov8" title="1">{
        err := o.db.Table(o.getTable()).Save(user).Error
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (o *userRepo) Update(userId string, user *models.User) error <span class="cov8" title="1">{
        tx := o.db.Table(o.getTable()).Where("id = ?", userId).UpdateColumns(user)
        if tx.Error != nil || tx.RowsAffected == 0 </span><span class="cov8" title="1">{
                return errors.New("error updating user")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (o *userRepo) Get(userId string) (*models.User, error) <span class="cov8" title="1">{
        var result *models.User

        err := o.db.Table(o.getTable()).Where("id = ?", userId).First(&amp;result).Error
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

func (o *userRepo) Delete(userId string) error <span class="cov8" title="1">{
        tx := o.db.Table(o.getTable()).Where("id = ?", userId).Delete(&amp;models.User{})
        if tx.Error != nil || tx.RowsAffected == 0 </span><span class="cov8" title="1">{
                return errors.New("error deleting user")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package routes

import (
        "inventory-management/handlers"
        "inventory-management/repository"
        "inventory-management/services/articles"

        "github.com/gin-gonic/gin"
        "gorm.io/gorm"
)

func ArticleRoutes(r *gin.Engine, db *gorm.DB) <span class="cov0" title="0">{
        articleRepo := repository.NewArticleRepo(db)
        articleService := articles.NewArticleService(articleRepo)
        articleHandler := handlers.NewArticleHandler(articleService)

        r.GET("/articles/:id", articleHandler.GetArticle)
        r.POST("/articles", articleHandler.CreateArticle)
        r.DELETE("/articles/:id", articleHandler.DeleteArticle)
        r.PUT("/articles/:id", articleHandler.UpdateArticle)
        r.GET("/articles-list", articleHandler.ListArticles)
        r.PATCH("/articles/:id", articleHandler.UpdateArticleStock)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package routes

import (
        "inventory-management/handlers"
        "inventory-management/repository"
        "inventory-management/services/orders"

        "github.com/gin-gonic/gin"
        "gorm.io/gorm"
)

func OrderRoutes(r *gin.Engine, db *gorm.DB) <span class="cov0" title="0">{
        orderRepo := repository.NewOrderRepo(db)
        orderItemRepo := repository.NewOrderItemRepo(db)

        orderService := orders.NewOrderService(orderRepo, orderItemRepo)
        orderHandler := handlers.NewOrderHandler(orderService)

        r.GET("/orders/:id", orderHandler.GetOrder)
        r.POST("/orders", orderHandler.CreateOrder)
        r.DELETE("/orders/:id", orderHandler.DeleteOrder)
        r.PUT("/orders/:id", orderHandler.UpdateOrder)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package routes

import (
        "github.com/gin-gonic/gin"
        "gorm.io/gorm"
)

func Router(r *gin.Engine, db *gorm.DB) <span class="cov0" title="0">{
        ArticleRoutes(r, db)
        OrderRoutes(r, db)
        UserRoutes(r, db)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package routes

import (
        "inventory-management/handlers"
        "inventory-management/repository"
        "inventory-management/services/users"

        "github.com/gin-gonic/gin"
        "gorm.io/gorm"
)

func UserRoutes(r *gin.Engine, db *gorm.DB) <span class="cov0" title="0">{
        userRepo := repository.NewUserRepo(db)
        addressRepo := repository.NewAddressRepo(db)

        userService := users.NewUserService(userRepo, addressRepo)
        userHandler := handlers.NewUserHandler(userService)

        r.GET("/users/:id", userHandler.GetUser)
        r.POST("/users", userHandler.CreateUser)
        r.DELETE("/users/:id", userHandler.DeleteUser)
        r.PUT("/users/:id", userHandler.UpdateUser)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package articles

import (
        "inventory-management/dtos"
        "inventory-management/models"
        "inventory-management/repository"
        "log"
)

type ArticleService interface {
        CreateArticle(req *dtos.Article) error
        UpdateArticle(id string, req *dtos.Article) error
        GetArticle(articleId string) (*dtos.Article, error)
        ListArticle() ([]*dtos.Article, error)
        DeleteArticle(articleId string) error
        UpdateArticleStock(articleId string, req *dtos.UpdateStock) error
}

type articleService struct {
        articleRepo repository.ArticleRepo
}

func NewArticleService(articleRepo repository.ArticleRepo) ArticleService <span class="cov8" title="1">{
        return &amp;articleService{
                articleRepo: articleRepo,
        }
}</span>

func (a *articleService) CreateArticle(req *dtos.Article) error <span class="cov8" title="1">{
        model := ArticleDtosToModel(req)

        err := a.articleRepo.Create(model)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (a *articleService) UpdateArticle(id string, req *dtos.Article) error <span class="cov8" title="1">{
        model := ArticleDtosToModel(req)

        err := a.articleRepo.Update(id, model)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (a *articleService) GetArticle(articleId string) (*dtos.Article, error) <span class="cov8" title="1">{
        article, err := a.articleRepo.Get(articleId)
        if err != nil </span><span class="cov8" title="1">{
                log.Println("unable to get article")
                return nil, err
        }</span>

        <span class="cov8" title="1">result := ArticleModelToDtos(article)

        return result[0], nil</span>
}

func (a *articleService) ListArticle() ([]*dtos.Article, error) <span class="cov8" title="1">{
        articles, err := a.articleRepo.GetAll()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return ArticleModelToDtos(articles...), nil</span>
}

func (a *articleService) DeleteArticle(articleId string) error <span class="cov8" title="1">{
        err := a.articleRepo.Delete(articleId)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (a *articleService) UpdateArticleStock(articleId string, req *dtos.UpdateStock) error <span class="cov8" title="1">{
        err := a.articleRepo.UpdateArticleStock(articleId, req.NewStock)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func ArticleModelToDtos(m ...*models.Article) []*dtos.Article <span class="cov8" title="1">{
        var a []*dtos.Article

        for _, v := range m </span><span class="cov8" title="1">{
                a = append(a, &amp;dtos.Article{
                        ArticleId:   v.ArticleId,
                        ArticleName: v.ArticleName,
                        Price:       v.Price,
                        Stock:       v.Stock,
                })
        }</span>

        <span class="cov8" title="1">return a</span>
}

func ArticleDtosToModel(m *dtos.Article) *models.Article <span class="cov8" title="1">{
        return &amp;models.Article{
                ArticleId:   m.ArticleId,
                ArticleName: m.ArticleName,
                Price:       m.Price,
                Stock:       m.Stock,
        }
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: services/articles/articleService.go

// Package mocks is a generated GoMock package.
package mocks

import (
        dtos "inventory-management/dtos"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockArticleService is a mock of ArticleService interface.
type MockArticleService struct {
        ctrl     *gomock.Controller
        recorder *MockArticleServiceMockRecorder
}

// MockArticleServiceMockRecorder is the mock recorder for MockArticleService.
type MockArticleServiceMockRecorder struct {
        mock *MockArticleService
}

// NewMockArticleService creates a new mock instance.
func NewMockArticleService(ctrl *gomock.Controller) *MockArticleService <span class="cov0" title="0">{
        mock := &amp;MockArticleService{ctrl: ctrl}
        mock.recorder = &amp;MockArticleServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockArticleService) EXPECT() *MockArticleServiceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateArticle mocks base method.
func (m *MockArticleService) CreateArticle(req *dtos.Article) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateArticle", req)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateArticle indicates an expected call of CreateArticle.
func (mr *MockArticleServiceMockRecorder) CreateArticle(req interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateArticle", reflect.TypeOf((*MockArticleService)(nil).CreateArticle), req)
}</span>

// DeleteArticle mocks base method.
func (m *MockArticleService) DeleteArticle(articleId string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteArticle", articleId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteArticle indicates an expected call of DeleteArticle.
func (mr *MockArticleServiceMockRecorder) DeleteArticle(articleId interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteArticle", reflect.TypeOf((*MockArticleService)(nil).DeleteArticle), articleId)
}</span>

// GetArticle mocks base method.
func (m *MockArticleService) GetArticle(articleId string) (*dtos.Article, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetArticle", articleId)
        ret0, _ := ret[0].(*dtos.Article)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetArticle indicates an expected call of GetArticle.
func (mr *MockArticleServiceMockRecorder) GetArticle(articleId interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetArticle", reflect.TypeOf((*MockArticleService)(nil).GetArticle), articleId)
}</span>

// ListArticle mocks base method.
func (m *MockArticleService) ListArticle() ([]*dtos.Article, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListArticle")
        ret0, _ := ret[0].([]*dtos.Article)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListArticle indicates an expected call of ListArticle.
func (mr *MockArticleServiceMockRecorder) ListArticle() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListArticle", reflect.TypeOf((*MockArticleService)(nil).ListArticle))
}</span>

// UpdateArticle mocks base method.
func (m *MockArticleService) UpdateArticle(id string, req *dtos.Article) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateArticle", id, req)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateArticle indicates an expected call of UpdateArticle.
func (mr *MockArticleServiceMockRecorder) UpdateArticle(id, req interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateArticle", reflect.TypeOf((*MockArticleService)(nil).UpdateArticle), id, req)
}</span>

// UpdateArticleStock mocks base method.
func (m *MockArticleService) UpdateArticleStock(articleId string, req *dtos.UpdateStock) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateArticleStock", articleId, req)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateArticleStock indicates an expected call of UpdateArticleStock.
func (mr *MockArticleServiceMockRecorder) UpdateArticleStock(articleId, req interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateArticleStock", reflect.TypeOf((*MockArticleService)(nil).UpdateArticleStock), articleId, req)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: services/orders/orderService.go

// Package mocks is a generated GoMock package.
package mocks

import (
        dtos "inventory-management/dtos"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockOrderService is a mock of OrderService interface.
type MockOrderService struct {
        ctrl     *gomock.Controller
        recorder *MockOrderServiceMockRecorder
}

// MockOrderServiceMockRecorder is the mock recorder for MockOrderService.
type MockOrderServiceMockRecorder struct {
        mock *MockOrderService
}

// NewMockOrderService creates a new mock instance.
func NewMockOrderService(ctrl *gomock.Controller) *MockOrderService <span class="cov0" title="0">{
        mock := &amp;MockOrderService{ctrl: ctrl}
        mock.recorder = &amp;MockOrderServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockOrderService) EXPECT() *MockOrderServiceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateOrder mocks base method.
func (m *MockOrderService) CreateOrder(req *dtos.Order) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateOrder", req)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateOrder indicates an expected call of CreateOrder.
func (mr *MockOrderServiceMockRecorder) CreateOrder(req interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateOrder", reflect.TypeOf((*MockOrderService)(nil).CreateOrder), req)
}</span>

// DeleteOrder mocks base method.
func (m *MockOrderService) DeleteOrder(orderId string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteOrder", orderId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteOrder indicates an expected call of DeleteOrder.
func (mr *MockOrderServiceMockRecorder) DeleteOrder(orderId interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteOrder", reflect.TypeOf((*MockOrderService)(nil).DeleteOrder), orderId)
}</span>

// GetOrder mocks base method.
func (m *MockOrderService) GetOrder(orderId string) (*dtos.Order, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetOrder", orderId)
        ret0, _ := ret[0].(*dtos.Order)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetOrder indicates an expected call of GetOrder.
func (mr *MockOrderServiceMockRecorder) GetOrder(orderId interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrder", reflect.TypeOf((*MockOrderService)(nil).GetOrder), orderId)
}</span>

// UpdateOrder mocks base method.
func (m *MockOrderService) UpdateOrder(id string, req *dtos.Order) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateOrder", id, req)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateOrder indicates an expected call of UpdateOrder.
func (mr *MockOrderServiceMockRecorder) UpdateOrder(id, req interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateOrder", reflect.TypeOf((*MockOrderService)(nil).UpdateOrder), id, req)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: services/users/userService.go

// Package mocks is a generated GoMock package.
package mocks

import (
        dtos "inventory-management/dtos"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockUserService is a mock of UserService interface.
type MockUserService struct {
        ctrl     *gomock.Controller
        recorder *MockUserServiceMockRecorder
}

// MockUserServiceMockRecorder is the mock recorder for MockUserService.
type MockUserServiceMockRecorder struct {
        mock *MockUserService
}

// NewMockUserService creates a new mock instance.
func NewMockUserService(ctrl *gomock.Controller) *MockUserService <span class="cov0" title="0">{
        mock := &amp;MockUserService{ctrl: ctrl}
        mock.recorder = &amp;MockUserServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserService) EXPECT() *MockUserServiceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateUser mocks base method.
func (m *MockUserService) CreateUser(req *dtos.User) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateUser", req)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// CreateUser indicates an expected call of CreateUser.
func (mr *MockUserServiceMockRecorder) CreateUser(req interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockUserService)(nil).CreateUser), req)
}</span>

// DeleteUser mocks base method.
func (m *MockUserService) DeleteUser(userId string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteUser", userId)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteUser indicates an expected call of DeleteUser.
func (mr *MockUserServiceMockRecorder) DeleteUser(userId interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteUser", reflect.TypeOf((*MockUserService)(nil).DeleteUser), userId)
}</span>

// GetUser mocks base method.
func (m *MockUserService) GetUser(userId string) (*dtos.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUser", userId)
        ret0, _ := ret[0].(*dtos.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetUser indicates an expected call of GetUser.
func (mr *MockUserServiceMockRecorder) GetUser(userId interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUser", reflect.TypeOf((*MockUserService)(nil).GetUser), userId)
}</span>

// UpdateUser mocks base method.
func (m *MockUserService) UpdateUser(id string, req *dtos.User) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateUser", id, req)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateUser indicates an expected call of UpdateUser.
func (mr *MockUserServiceMockRecorder) UpdateUser(id, req interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUser", reflect.TypeOf((*MockUserService)(nil).UpdateUser), id, req)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package orders

import (
        "inventory-management/constants"
        "inventory-management/dtos"
        "inventory-management/models"
        "inventory-management/repository"
        "time"

        "github.com/google/uuid"
)

type OrderService interface {
        CreateOrder(req *dtos.Order) error
        UpdateOrder(id string, req *dtos.Order) error
        GetOrder(orderId string) (*dtos.Order, error)
        DeleteOrder(orderId string) error
}

type orderService struct {
        orderRepo     repository.OrderRepo
        orderItemRepo repository.OrderItemRepo
}

func NewOrderService(orderRepo repository.OrderRepo, orderItemRepo repository.OrderItemRepo) OrderService <span class="cov8" title="1">{
        return &amp;orderService{
                orderRepo:     orderRepo,
                orderItemRepo: orderItemRepo,
        }
}</span>

func (o *orderService) CreateOrder(req *dtos.Order) error <span class="cov8" title="1">{
        orderModel, itemsModel := OrderDtosToModel(req)

        err := o.orderRepo.Create(orderModel)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = o.orderItemRepo.Create(itemsModel...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (o *orderService) UpdateOrder(id string, req *dtos.Order) error <span class="cov8" title="1">{
        if req.OrderId == "" </span><span class="cov0" title="0">{
                return constants.ErrorOrderIdEmpty
        }</span>

        <span class="cov8" title="1">orderModel, itemsModel := OrderDtosToModel(req)

        err := o.orderRepo.Update(id, orderModel)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">orderItems, err := o.orderItemRepo.GetByOrder(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">itemsMap := make(map[string]struct{})
        for _, v := range itemsModel </span><span class="cov8" title="1">{
                itemsMap[v.OrderItemId] = struct{}{}
        }</span>

        <span class="cov8" title="1">var deletedItems []string
        for _, v := range orderItems </span><span class="cov0" title="0">{
                if _, exists := itemsMap[v.OrderItemId]; !exists </span><span class="cov0" title="0">{
                        deletedItems = append(deletedItems, v.OrderItemId)
                }</span>
        }

        <span class="cov8" title="1">if len(deletedItems) &gt; 0 </span><span class="cov0" title="0">{
                err := o.orderItemRepo.DeleteAll(deletedItems)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">err = o.orderItemRepo.Upsert(itemsModel...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (o *orderService) GetOrder(orderId string) (*dtos.Order, error) <span class="cov8" title="1">{
        order, err := o.orderRepo.Get(orderId)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">orderItems, err := o.orderItemRepo.GetByOrder(orderId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := OrderModelToDtos(order, orderItems)

        return result, nil</span>
}

func (o *orderService) DeleteOrder(orderId string) error <span class="cov8" title="1">{
        err := o.orderRepo.Delete(orderId)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func OrderModelToDtos(m *models.Order, i []*models.OrderItem) *dtos.Order <span class="cov8" title="1">{
        o := &amp;dtos.Order{
                OrderId:     m.OrderId,
                CustomerId:  m.CustomerId,
                OrderedAt:   m.OrderedAt,
                TotalAmount: m.TotalAmount,
                NoOfItems:   m.NoOfItems,
                Items:       []*dtos.OrderItems{},
        }

        var items []*dtos.OrderItems
        for _, v := range i </span><span class="cov8" title="1">{
                items = append(items, &amp;dtos.OrderItems{
                        OrderItemId: v.OrderItemId,
                        OrderId:     v.OrderId,
                        ArticleId:   v.ArticleId,
                        Quantity:    v.Quantity,
                })
        }</span>

        <span class="cov8" title="1">o.Items = items

        return o</span>
}

func OrderDtosToModel(m *dtos.Order) (*models.Order, []*models.OrderItem) <span class="cov8" title="1">{
        orderId := m.OrderId
        if orderId == "" </span><span class="cov0" title="0">{
                orderId = uuid.NewString()
        }</span>

        <span class="cov8" title="1">if m.OrderedAt.IsZero() </span><span class="cov0" title="0">{
                m.OrderedAt = time.Now().UTC()
        }</span>

        <span class="cov8" title="1">order := &amp;models.Order{
                OrderId:     orderId,
                CustomerId:  m.CustomerId,
                OrderedAt:   m.OrderedAt,
                TotalAmount: m.TotalAmount,
                NoOfItems:   len(m.Items),
        }

        var orderItems []*models.OrderItem
        for _, v := range m.Items </span><span class="cov8" title="1">{
                if v.OrderItemId == "" </span><span class="cov8" title="1">{
                        v.OrderItemId = uuid.NewString()
                }</span>

                <span class="cov8" title="1">orderItems = append(orderItems, &amp;models.OrderItem{
                        OrderItemId: v.OrderItemId,
                        OrderId:     orderId,
                        ArticleId:   v.ArticleId,
                        Quantity:    v.Quantity,
                })</span>
        }

        <span class="cov8" title="1">return order, orderItems</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package users

import (
        "inventory-management/dtos"
        "inventory-management/models"
        "inventory-management/repository"

        "github.com/google/uuid"
)

type UserService interface {
        CreateUser(req *dtos.User) error
        UpdateUser(id string, req *dtos.User) error
        GetUser(userId string) (*dtos.User, error)
        DeleteUser(userId string) error
}

type userService struct {
        userRepo    repository.UserRepo
        addressRepo repository.AddressRepo
}

func NewUserService(userRepo repository.UserRepo, addressRepo repository.AddressRepo) UserService <span class="cov8" title="1">{
        return &amp;userService{
                userRepo:    userRepo,
                addressRepo: addressRepo,
        }
}</span>

func (o *userService) CreateUser(req *dtos.User) error <span class="cov8" title="1">{
        userModel, addressModel := UserDtosToModel(req)

        err := o.userRepo.Upsert(userModel)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = o.addressRepo.Upsert(addressModel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (o *userService) UpdateUser(id string, req *dtos.User) error <span class="cov8" title="1">{
        userModel, addressModel := UserDtosToModel(req)

        err := o.userRepo.Upsert(userModel)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = o.addressRepo.Upsert(addressModel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (o *userService) GetUser(userId string) (*dtos.User, error) <span class="cov8" title="1">{
        user, err := o.userRepo.Get(userId)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">address, err := o.addressRepo.Get(user.AddressId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := UserModelToDtos(user, address)

        return result, nil</span>
}

func (o *userService) DeleteUser(userId string) error <span class="cov8" title="1">{
        err := o.userRepo.Delete(userId)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func UserModelToDtos(m *models.User, a *models.Address) *dtos.User <span class="cov8" title="1">{
        user := &amp;dtos.User{
                Id:     m.Id,
                Name:   m.Name,
                Email:  m.Email,
                Mobile: m.Mobile,
                Address: dtos.Address{
                        AddressId: a.AddressId,
                        Line1:     a.Line1,
                        Line2:     a.Line2,
                        City:      a.City,
                        State:     a.State,
                        Country:   a.Country,
                        ZipCode:   a.ZipCode,
                },
                Role: m.Role,
        }

        return user
}</span>

func UserDtosToModel(m *dtos.User) (*models.User, *models.Address) <span class="cov8" title="1">{
        if m.Id == "" </span><span class="cov0" title="0">{
                m.Id = uuid.NewString()
        }</span>

        <span class="cov8" title="1">addressId := m.Address.AddressId
        if addressId == "" </span><span class="cov0" title="0">{
                addressId = uuid.NewString()
        }</span>

        <span class="cov8" title="1">userModel := &amp;models.User{
                Id:        m.Id,
                Name:      m.Name,
                Email:     m.Email,
                Mobile:    m.Mobile,
                AddressId: addressId,
                Role:      m.Role,
        }

        addressModel := &amp;models.Address{
                AddressId: addressId,
                Line1:     m.Address.Line1,
                Line2:     m.Address.Line2,
                City:      m.Address.City,
                State:     m.Address.State,
                Country:   m.Address.Country,
                ZipCode:   m.Address.ZipCode,
        }

        return userModel, addressModel</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
